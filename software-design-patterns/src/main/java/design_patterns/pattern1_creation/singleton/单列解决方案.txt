TODO: 1. 直接加锁处理，新版JVM对性能的影响很小
@ThreadSafe
public class SafeLazyInitialization {
    private static Resource resource;

    public static synchronized Resource getInstance() {
        if (resource == null)
            resource = new Resource();
        return resource;
    }

    static class Resource {
    }
}

TODO. 2. With inner static holder 保证延迟加载
@ThreadSafe
public class ResourceFactory {

    // This class will be lazily initialised 只要不调用static方法则不会创建实例
    private static class ResourceHolder {
        public static Resource resource = new Resource();
    }

    public static Resource getResource() {
        return ResourceHolder.resource;
    }

    static class Resource {
    }
}

TODO. 3. Using "volatile"
class ResourceFactory {
  private volatile Resource resource;

  public Resource getResource() {
     Resource localResource = resource;
     if (localResource == null) {
        synchronized (this) {
           localResource = resource;
           if (localResource == null) {
              localResource = new Resource();
           }
        }
     }
     return localResource;
  }

  static class Resource {
  }
}